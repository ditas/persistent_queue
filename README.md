# PerQ

### Что это?

Это персистентная очередь на двух стеках.
Персистентность достигается сохранением операций над очередью в ets таблице. Если требуется хранение на диске логично будет заменить ets на, например, mnesia.

### Как это работает?

Просто.

```elixir
iex -S mix

PerQ.Queue.add(1)
PerQ.Queue.add(2)
PerQ.Queue.add(3)
```
Это мы запустили консоль и добавили 3 элемента в очередь

```elixir
PerQ.Queue.stack()
```
Посмотреть, что в очереди

```elixir
PerQ.Queue.get("some_ref")
PerQ.Queue.ack("some_ref")
```
Получить из очереди значение с подтверждением. Если подтверждение не было отправлено, то, через 15 секунд сработает таймер и выполнит reject. Иными словами, выбранное значение будет добавлено в конец очереди. Того же результата (не дожидаясь таймера) можно добиться, выполнив

```elixir
PerQ.Queue.get("some_ref")
PerQ.Queue.reject("some_ref")
```
###### Внимание!
Если выполнить повторно get с уже существуюшим ref'ом - будет возвращена ошибка. Иными словами, для каждой операции get должен быть уникальный ref, до тех пор пока эта операция на завершилась ack'ом или reject'ом.

### Как работает откат?
Выполнение каждой операции (add/get) возвращает кортеж вида {:ok, ... timestamp, operation_num}. timestamp можно считать ключом данной операции. Для отката на состояние соответствующей операции необходимо выполнить

```elixir
PerQ.Queue.revert(timestamp)
```
В ответ мы получим состояние очереди на сооветствующее время. При этом текущая очередь не изменится.

### Прочее

Добавлены тесты на основные операции. Запускаются:

```elixir
mix test
```